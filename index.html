<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Star Particle Animator</title>
  <style>
    :root {
      color-scheme: dark;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
    }
    body {
      margin: 0;
      padding: 16px;
      background: #050505;
      color: #f5f5f5;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }
    h1 {
      font-size: 1.2rem;
      margin: 0 0 4px 0;
    }
    #top {
      display: flex;
      flex-wrap: wrap;
      gap: 16px;
      align-items: flex-start;
    }
    #controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px 16px;
      align-items: flex-end;
      max-width: 1100px;
    }
    .control-group {
      display: flex;
      flex-direction: column;
      gap: 4px;
      font-size: 0.85rem;
    }
    .control-group input,
    .control-group select {
      padding: 4px 6px;
      border-radius: 4px;
      border: 1px solid #444;
      background: #111;
      color: #f5f5f5;
      min-width: 80px;
    }
    .control-group input[type="range"] {
      min-width: 120px;
    }
    label {
      opacity: 0.8;
    }
    button {
      padding: 6px 12px;
      border-radius: 6px;
      border: 1px solid #666;
      background: #222;
      color: #f5f5f5;
      cursor: pointer;
      font-size: 0.9rem;
    }
    button:hover {
      background: #333;
    }
    #canvas-container {
      border-radius: 8px;
      border: 1px solid #333;
      padding: 8px;
      background: radial-gradient(circle at top, #202020 0, #050505 60%);
      display: flex;
      justify-content: center;
      align-items: center;
      max-height: calc(100vh - 220px);
      overflow: auto;
    }
    #starCanvas {
      max-width: 100%;
      max-height: 100%;
      display: block;
      background: #000;
    }
    #status {
      font-size: 0.8rem;
      opacity: 0.8;
      min-height: 1.2em;
    }
    #status.error {
      color: #ff6b6b;
    }
    #detectionStatus {
      font-size: 0.8rem;
      opacity: 0.8;
      min-height: 1.2em;
      margin-top: -8px;
    }
    #detectionStatus.error {
      color: #ff6b6b;
    }
    .inline-inputs {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    .inline-inputs label {
      margin-right: 4px;
    }
  </style>
</head>
<body>
  <div id="top">
    <div>
      <h1>Star Particle Animator</h1>
      <div id="status">Step 1: Load an image of your red star on black.</div>
    </div>

    <div id="controls">
      <!-- Image / resolution / duration -->
      <div class="control-group">
        <label for="imageLoader">Star image</label>
        <input type="file" id="imageLoader" accept="image/*" />
      </div>

      <div class="control-group">
        <label for="resolutionSelect">Resolution preset</label>
        <select id="resolutionSelect">
          <option value="3840x2160">4K UHD (3840 x 2160)</option>
          <option value="2560x1440">1440p (2560 x 1440)</option>
          <option value="1920x1080">1080p (1920 x 1080)</option>
          <option value="1280x720">720p (1280 x 720)</option>
          <option value="custom">Custom</option>
        </select>
      </div>

      <div class="control-group">
        <label>Canvas width (px)</label>
        <input type="number" id="widthInput" min="128" value="3840" />
      </div>

      <div class="control-group">
        <label>Canvas height (px)</label>
        <input type="number" id="heightInput" min="128" value="2160" />
      </div>

      <div class="control-group">
        <label for="durationInput">Duration (seconds)</label>
        <input type="number" id="durationInput" min="1" step="0.5" value="5" />
      </div>

      <div class="control-group">
        <label for="fpsInput">FPS</label>
        <input type="number" id="fpsInput" min="1" max="120" value="30" />
      </div>

      <div class="control-group">
        <label for="flowModeSelect">Flow pattern</label>
        <select id="flowModeSelect">
          <option value="classic">Classic tri-beam</option>
          <option value="leftToRightBurst">Left-to-right, burst at tip</option>
          <option value="leftToRightWind">Left-to-right with wind</option>
          <option value="radial">Radiate from center</option>
          <option value="spiral">Spiral drift</option>
          <option value="cone">Cone sweep</option>
        </select>
      </div>

      <div class="control-group">
        <label>Spiral / radial center (px)</label>
        <div class="inline-inputs">
          <label for="spiralCenterX">X</label>
          <input type="number" id="spiralCenterX" min="0" value="1920" />
          <label for="spiralCenterY">Y</label>
          <input type="number" id="spiralCenterY" min="0" value="1080" />
        </div>
      </div>

      <div class="control-group">
        <label>Cone origin (px)</label>
        <div class="inline-inputs">
          <label for="coneOriginX">X</label>
          <input type="number" id="coneOriginX" min="0" value="200" />
          <label for="coneOriginY">Y</label>
          <input type="number" id="coneOriginY" min="0" value="1080" />
        </div>
      </div>

      <div class="control-group">
        <label for="coneDirection">Cone direction (deg)</label>
        <input type="number" id="coneDirection" min="-360" max="360" value="0" />
      </div>

      <div class="control-group">
        <label for="coneSpread">Cone spread (deg)</label>
        <input type="number" id="coneSpread" min="1" max="360" value="160" />
      </div>

      <div class="control-group">
        <label for="coneCenterBias">Cone center bias</label>
        <input type="range" id="coneCenterBias" min="0" max="1" step="0.05" value="0.6" />
      </div>

      <div class="control-group">
        <label for="codecSelect">Codec preference</label>
        <select id="codecSelect">
          <option value="auto">Auto (browser default)</option>
          <option value="h264">H.264 (if supported)</option>
          <option value="vp9">VP9</option>
          <option value="vp8">VP8</option>
        </select>
      </div>

      <div class="control-group">
        <label for="bitrateInput">Recording bitrate (kbps)</label>
        <input
          type="number"
          id="bitrateInput"
          min="500"
          max="100000"
          step="500"
          value="20000"
        />
      </div>

      <!-- Detection -->
      <div class="control-group">
        <label for="redThreshold">Red detection threshold</label>
        <input type="range" id="redThreshold" min="50" max="255" value="140" />
      </div>

      <!-- NEW: Particle controls -->
      <div class="control-group">
        <label for="particlesInput">Particles per layer</label>
        <input type="number" id="particlesInput" min="50" max="2000" value="350" />
      </div>

      <div class="control-group">
        <label for="sizeInput">Size multiplier</label>
        <input type="range" id="sizeInput" min="0.5" max="4" step="0.1" value="2" />
      </div>

      <div class="control-group">
        <label for="speedInput">Speed multiplier</label>
        <input type="range" id="speedInput" min="0.2" max="4" step="0.1" value="1.8" />
      </div>

      <div class="control-group">
        <label for="windInput">Wind drift (px/s)</label>
        <input type="range" id="windInput" min="-150" max="150" step="5" value="20" />
      </div>

      <div class="control-group">
        <label for="lifeMinInput">Life min (s)</label>
        <input type="number" id="lifeMinInput" min="0.1" max="5" step="0.1" value="0.4" />
      </div>

      <div class="control-group">
        <label for="lifeMaxInput">Life max (s)</label>
        <input type="number" id="lifeMaxInput" min="0.2" max="8" step="0.1" value="1.2" />
      </div>

      <!-- Crop controls -->
      <div class="control-group">
        <label for="cropToggle">Crop to viewport</label>
        <div class="inline-inputs">
          <input type="checkbox" id="cropToggle" />
          <button type="button" id="cropToViewportBtn">Use canvas center</button>
        </div>
      </div>

      <div class="control-group">
        <label>Crop origin (px)</label>
        <div class="inline-inputs">
          <label for="cropXInput">X</label>
          <input type="number" id="cropXInput" min="0" value="0" />
          <label for="cropYInput">Y</label>
          <input type="number" id="cropYInput" min="0" value="0" />
        </div>
      </div>

      <div class="control-group">
        <label>Crop size (px)</label>
        <div class="inline-inputs">
          <label for="cropWInput">W</label>
          <input type="number" id="cropWInput" min="1" value="0" />
          <label for="cropHInput">H</label>
          <input type="number" id="cropHInput" min="1" value="0" />
        </div>
      </div>

      <!-- Actions -->
      <div class="control-group">
        <label>&nbsp;</label>
        <button id="previewBtn" type="button">Start / Refresh Preview</button>
      </div>

      <div class="control-group">
        <label>&nbsp;</label>
        <button id="recordBtn" type="button">Record &amp; Download</button>
      </div>
    </div>
  </div>

  <div id="detectionStatus" aria-live="polite"></div>

  <div id="canvas-container">
    <canvas id="starCanvas"></canvas>
  </div>

  <script>
    // === DOM references ===
    const canvas = document.getElementById("starCanvas");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    const imageLoader = document.getElementById("imageLoader");
    const resolutionSelect = document.getElementById("resolutionSelect");
    const widthInput = document.getElementById("widthInput");
    const heightInput = document.getElementById("heightInput");
    const durationInput = document.getElementById("durationInput");
    const fpsInput = document.getElementById("fpsInput");
    const codecSelect = document.getElementById("codecSelect");
    const bitrateInput = document.getElementById("bitrateInput");
    const flowModeSelect = document.getElementById("flowModeSelect");
    const redThresholdInput = document.getElementById("redThreshold");
    const windInput = document.getElementById("windInput");
    const spiralCenterXInput = document.getElementById("spiralCenterX");
    const spiralCenterYInput = document.getElementById("spiralCenterY");
    const coneOriginXInput = document.getElementById("coneOriginX");
    const coneOriginYInput = document.getElementById("coneOriginY");
    const coneDirectionInput = document.getElementById("coneDirection");
    const coneSpreadInput = document.getElementById("coneSpread");
    const coneCenterBiasInput = document.getElementById("coneCenterBias");

    // NEW: particle control inputs
    const particlesInput = document.getElementById("particlesInput");
    const sizeInput = document.getElementById("sizeInput");
    const speedInput = document.getElementById("speedInput");
    const lifeMinInput = document.getElementById("lifeMinInput");
    const lifeMaxInput = document.getElementById("lifeMaxInput");

    // Crop controls
    const cropToggle = document.getElementById("cropToggle");
    const cropXInput = document.getElementById("cropXInput");
    const cropYInput = document.getElementById("cropYInput");
    const cropWInput = document.getElementById("cropWInput");
    const cropHInput = document.getElementById("cropHInput");
    const cropToViewportBtn = document.getElementById("cropToViewportBtn");

    const previewBtn = document.getElementById("previewBtn");
    const recordBtn = document.getElementById("recordBtn");
    const statusDiv = document.getElementById("status");
    const detectionStatusDiv = document.getElementById("detectionStatus");

    if (!ctx) {
      console.error("2D context not available.");
      statusDiv.textContent = "Your browser doesn't support Canvas 2D.";
      statusDiv.classList.add("error");
    }

    // Offscreen canvas for analysis
    const maskCanvas = document.createElement("canvas");
    const maskCtx = maskCanvas.getContext("2d", { willReadFrequently: true });

    // State
    let sourceImage = null;
    let starMask = [];
    let animationId = null;
    let lastTime = 0;

    const NUM_LAYERS = 3;
    const baseAngles = [0, Math.PI / 2, -Math.PI / 2];
    const baseSpeeds = [60, 35, 90];
    const angleSpread = Math.PI / 2;

    const particles = [];

    // Particle tuning variables (read from UI)
    let particlesPerLayer = 350;
    let sizeMultiplier = 2;
    let speedMultiplier = 1.8;
    let windDrift = 20;
    let lifeMin = 0.4;
    let lifeMax = 1.2;
    let flowMode = "classic";
    let spiralCenterX = canvas.width / 2;
    let spiralCenterY = canvas.height / 2;
    let coneOriginX = 200;
    let coneOriginY = 1080;
    let coneDirectionDeg = 0;
    let coneSpreadDeg = 160;
    let coneCenterBias = 0.6;

    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

    const crop = {
      enabled: false,
      x: 0,
      y: 0,
      w: 0,
      h: 0
    };

    // Recording
    let recorder = null;
    let recordedChunks = [];
    let recording = false;
    let recordEndTime = 0;
    let targetFPS = 30;

    function setStatus(msg, isError = false) {
      statusDiv.textContent = msg;
      statusDiv.classList.toggle("error", !!isError);
      console.log("[StarParticles]", msg);
    }

    function setDetectionStatus(msg, isError = false) {
      detectionStatusDiv.textContent = msg;
      detectionStatusDiv.classList.toggle("error", !!isError);
    }

    function applyResolution() {
      const w = parseInt(widthInput.value, 10) || 3840;
      const h = parseInt(heightInput.value, 10) || 2160;
      canvas.width = w;
      canvas.height = h;
      maskCanvas.width = w;
      maskCanvas.height = h;
    }

    function refreshAfterResolutionChange() {
      applyResolution();
      if (sourceImage) {
        buildStarMask();
        createParticles();
        startAnimation();
      }
    }

    const resolutionPresets = {
      "3840x2160": { w: 3840, h: 2160 },
      "2560x1440": { w: 2560, h: 1440 },
      "1920x1080": { w: 1920, h: 1080 },
      "1280x720": { w: 1280, h: 720 }
    };

    function setResolutionPreset(key) {
      const preset = resolutionPresets[key];
      if (!preset) return;
      widthInput.value = preset.w;
      heightInput.value = preset.h;
      applyResolution();
    }

    function syncPresetSelection() {
      const currentW = parseInt(widthInput.value, 10);
      const currentH = parseInt(heightInput.value, 10);
      const match = Object.entries(resolutionPresets).find(([, size]) => {
        return size.w === currentW && size.h === currentH;
      });
      resolutionSelect.value = match ? `${currentW}x${currentH}` : "custom";
    }

    function getCropRect(img) {
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      const safeWidth = Math.max(1, Math.min(crop.w || iw, iw));
      const safeHeight = Math.max(1, Math.min(crop.h || ih, ih));
      const safeX = Math.min(Math.max(0, crop.x), iw - safeWidth);
      const safeY = Math.min(Math.max(0, crop.y), ih - safeHeight);
      return crop.enabled
        ? { x: safeX, y: safeY, w: safeWidth, h: safeHeight }
        : { x: 0, y: 0, w: iw, h: ih };
    }

    function drawImageFit(ctx, img, targetW, targetH) {
      const iw = img.naturalWidth;
      const ih = img.naturalHeight;
      if (!iw || !ih) return;

      const { x: sx, y: sy, w: sw, h: sh } = getCropRect(img);
      const imgRatio = sw / sh;
      const canvasRatio = targetW / targetH;

      let dw, dh, dx, dy;
      if (imgRatio > canvasRatio) {
        dw = targetW;
        dh = targetW / imgRatio;
      } else {
        dh = targetH;
        dw = targetH * imgRatio;
      }
      dx = (targetW - dw) / 2;
      dy = (targetH - dh) / 2;

      ctx.drawImage(img, sx, sy, sw, sh, dx, dy, dw, dh);
    }

    function buildStarMask() {
      starMask = [];

      if (!sourceImage) {
        setStatus("No image loaded; using generic red swirl.", true);
        return;
      }

      maskCtx.clearRect(0, 0, maskCanvas.width, maskCanvas.height);
      maskCtx.fillStyle = "black";
      maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
      drawImageFit(maskCtx, sourceImage, maskCanvas.width, maskCanvas.height);

      const imgData = maskCtx.getImageData(0, 0, maskCanvas.width, maskCanvas.height);
      const data = imgData.data;
      const redThreshold = parseInt(redThresholdInput.value, 10) || 140;

      for (let y = 0; y < maskCanvas.height; y += 2) {
        for (let x = 0; x < maskCanvas.width; x += 2) {
          const idx = (y * maskCanvas.width + x) * 4;
          const r = data[idx];
          const g = data[idx + 1];
          const b = data[idx + 2];
          const a = data[idx + 3];

          if (a < 10) continue;
          const brightness = 0.299 * r + 0.587 * g + 0.114 * b;

          if (r >= redThreshold && r > g * 1.3 && r > b * 1.3 && brightness > 40) {
            starMask.push({ x, y, r, g, b });
          }
        }
      }

      if (starMask.length === 0) {
        setDetectionStatus(
          "No strong red detected; particles will be generic red over the canvas.",
          true
        );
      } else {
        setDetectionStatus(`Detected ~${starMask.length} red star pixels as emitters.`);
      }
    }

    // Read particle tuning values from UI
    function readParticleSettings() {
      particlesPerLayer = Math.max(
        10,
        Math.min(3000, parseInt(particlesInput.value, 10) || 350)
      );

      sizeMultiplier = Math.max(
        0.1,
        Math.min(10, parseFloat(sizeInput.value) || 1)
      );

      speedMultiplier = Math.max(
        0.1,
        Math.min(10, parseFloat(speedInput.value) || 1)
      );

      windDrift = Math.max(-400, Math.min(400, parseFloat(windInput.value) || 0));

      lifeMin = Math.max(0.05, parseFloat(lifeMinInput.value) || 0.4);
      lifeMax = Math.max(0.1, parseFloat(lifeMaxInput.value) || 1.2);
      if (lifeMax <= lifeMin) {
        lifeMax = lifeMin + 0.1;
      }

      flowMode = flowModeSelect.value || "classic";
      readSpiralCenter();
      readConeSettings();
    }

    function readSpiralCenter() {
      const fallbackX = canvas.width / 2;
      const fallbackY = canvas.height / 2;
      const parsedX = parseFloat(spiralCenterXInput.value);
      const parsedY = parseFloat(spiralCenterYInput.value);
      spiralCenterX = Number.isFinite(parsedX) ? parsedX : fallbackX;
      spiralCenterY = Number.isFinite(parsedY) ? parsedY : fallbackY;

      spiralCenterX = Math.max(0, Math.min(canvas.width, spiralCenterX));
      spiralCenterY = Math.max(0, Math.min(canvas.height, spiralCenterY));

      spiralCenterXInput.value = Math.round(spiralCenterX);
      spiralCenterYInput.value = Math.round(spiralCenterY);
    }

    function readConeSettings() {
      const fallbackW = parseFloat(widthInput.value) || canvas.width || 3840;
      const fallbackH = parseFloat(heightInput.value) || canvas.height || 2160;
      coneOriginX = clamp(parseFloat(coneOriginXInput.value) || 0, 0, fallbackW);
      coneOriginY = clamp(parseFloat(coneOriginYInput.value) || 0, 0, fallbackH);
      coneDirectionDeg = parseFloat(coneDirectionInput.value) || 0;
      coneSpreadDeg = clamp(parseFloat(coneSpreadInput.value) || 0, 0, 360);
      coneCenterBias = clamp(parseFloat(coneCenterBiasInput.value) || 0, 0, 1);
    }

    function sampleConeAngle(baseAngle, spreadRad, centerBiasAmount) {
      const halfSpread = Math.max(0, spreadRad / 2);
      const exponent = 1 + centerBiasAmount * 4;
      const magnitude = Math.pow(Math.random(), exponent) * halfSpread;
      const direction = Math.random() < 0.5 ? -1 : 1;
      return baseAngle + direction * magnitude;
    }

    function syncCropInputsFromImage() {
      if (!sourceImage) return;
      cropXInput.value = Math.round(crop.x);
      cropYInput.value = Math.round(crop.y);
      cropWInput.value = Math.round(crop.w || sourceImage.naturalWidth);
      cropHInput.value = Math.round(crop.h || sourceImage.naturalHeight);
    }

    function readCropFromInputs() {
      if (!sourceImage) return;
      crop.enabled = cropToggle.checked;
      crop.x = parseInt(cropXInput.value, 10) || 0;
      crop.y = parseInt(cropYInput.value, 10) || 0;
      crop.w = parseInt(cropWInput.value, 10) || sourceImage.naturalWidth;
      crop.h = parseInt(cropHInput.value, 10) || sourceImage.naturalHeight;
      syncCropInputsFromImage();
    }

    function setCropToViewportCenter() {
      if (!sourceImage) return;
      const { naturalWidth: iw, naturalHeight: ih } = sourceImage;
      const viewportW = canvas.width;
      const viewportH = canvas.height;
      const cropSizeW = Math.min(viewportW, iw);
      const cropSizeH = Math.min(viewportH, ih);
      crop.enabled = true;
      crop.w = cropSizeW;
      crop.h = cropSizeH;
      crop.x = Math.max(0, Math.round((iw - cropSizeW) / 2));
      crop.y = Math.max(0, Math.round((ih - cropSizeH) / 2));
      cropToggle.checked = true;
      syncCropInputsFromImage();
      setStatus("Crop set to centered viewport size.");
      buildStarMask();
      createParticles();
    }

    function applyCropChange(message = "Crop updated.") {
      if (!sourceImage) return;
      readCropFromInputs();
      buildStarMask();
      createParticles();
      startAnimation();
      setStatus(message);
    }

    class Particle {
      constructor(layerIndex) {
        this.layer = layerIndex;
        this.reset();
      }
      reset() {
        readParticleSettings(); // ensure we use latest settings

        if (!starMask.length) {
          // Fallback: random red particles across canvas
          const useConeOrigin = flowMode === "cone";
          this.x = useConeOrigin ? coneOriginX : Math.random() * canvas.width;
          this.y = useConeOrigin ? coneOriginY : Math.random() * canvas.height;
          this.color = "rgba(255,0,0,1)";
          this.life = lifeMin + Math.random() * (lifeMax - lifeMin);
          this.age = Math.random() * this.life;
          this.#applyFlow({ x: this.x, y: this.y }, true);
          this.size = (1 + Math.random() * 2) * sizeMultiplier;
          return;
        }

        const p = starMask[Math.floor(Math.random() * starMask.length)];
        this.x = p.x + (Math.random() - 0.5) * 1.5;
        this.y = p.y + (Math.random() - 0.5) * 1.5;
        this.color = `rgba(${p.r},${p.g},${p.b},1)`;
        this.life = lifeMin + Math.random() * (lifeMax - lifeMin);
        this.age = Math.random() * this.life * 0.3;
        this.#applyFlow(p);
        const baseSize =
          this.layer === 0 ? 2.2 :
          this.layer === 1 ? 1.8 : 1.4;
        this.size = baseSize * sizeMultiplier;
      }
      update(dt) {
        this.age += dt;
        this.x += this.vx * dt;
        this.y += this.vy * dt;

        if (flowMode === "leftToRightBurst" && this.phase === "line") {
          const transitionTime = this.life * 0.65;
          if (this.age >= transitionTime) {
            const cx = canvas.width * 0.65;
            const cy = canvas.height * 0.5;
            const dx = this.x - cx;
            const dy = this.y - cy;
            const baseAngle = Math.atan2(dy, dx);
            const angle = baseAngle + (Math.random() - 0.5) * 0.6;
            const speed = 140 * speedMultiplier;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.phase = "burst";
          }
        }

        if (
          this.age > this.life ||
          this.x < -10 || this.x > canvas.width + 10 ||
          this.y < -10 || this.y > canvas.height + 10
        ) {
          this.reset();
        }
      }
      draw(ctx) {
        const t = this.age / this.life;
        const alpha = Math.max(0, 1 - t);
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.fillRect(this.x, this.y, this.size, this.size);
      }

      #applyFlow(emitter) {
        const base = baseSpeeds[this.layer] || baseSpeeds[0];

        if (flowMode === "leftToRightBurst") {
          const primarySpeed = 80 * speedMultiplier;
          this.vx = primarySpeed * (0.9 + Math.random() * 0.3);
          this.vy = (Math.random() - 0.5) * 25 * speedMultiplier;
          this.phase = "line";
          return;
        }

        if (flowMode === "leftToRightWind") {
          const primarySpeed = 90 * speedMultiplier;
          this.vx = primarySpeed * (0.85 + Math.random() * 0.3);
          this.vy = windDrift * 0.6 + (Math.random() - 0.5) * 12;
          this.phase = "wind";
          return;
        }

        if (flowMode === "radial") {
          const centerX = spiralCenterX;
          const centerY = spiralCenterY;
          const dx = (emitter?.x ?? this.x) - centerX;
          const dy = (emitter?.y ?? this.y) - centerY;
          const angle = Math.atan2(dy, dx) + (Math.random() - 0.5) * 0.2;
          const speed = 110 * speedMultiplier * (0.6 + Math.random() * 0.7);
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.phase = "radial";
          return;
        }

        if (flowMode === "spiral") {
          const orbit = base * 0.8 * speedMultiplier;
          const spiralAngle =
            Math.atan2((emitter?.y ?? this.y) - spiralCenterY, (emitter?.x ?? this.x) - spiralCenterX) +
            (Math.random() - 0.5) * 0.5;
          this.vx = Math.cos(spiralAngle + Math.PI / 2) * orbit;
          this.vy = Math.sin(spiralAngle + Math.PI / 2) * orbit;
          this.phase = "spiral";
          return;
        }

        if (flowMode === "cone") {
          const baseAngle = (coneDirectionDeg * Math.PI) / 180;
          const spreadRad = (coneSpreadDeg * Math.PI) / 180;
          const angle = sampleConeAngle(baseAngle, spreadRad, coneCenterBias);
          const speed = base * speedMultiplier * (0.55 + Math.random() * 0.9);
          this.vx = Math.cos(angle) * speed;
          this.vy = Math.sin(angle) * speed;
          this.phase = "cone";
          return;
        }

        // Classic tri-beam flow (default)
        const speed = base * speedMultiplier * (0.4 + Math.random() * 0.8);
        const angle =
          (baseAngles[this.layer] || baseAngles[0]) +
          (Math.random() - 0.5) * angleSpread;
        this.vx = Math.cos(angle) * speed;
        this.vy = Math.sin(angle) * speed;
        this.phase = "classic";
      }
    }

    function createParticles() {
      readParticleSettings();
      particles.length = 0;
      for (let layer = 0; layer < NUM_LAYERS; layer++) {
        for (let i = 0; i < particlesPerLayer; i++) {
          particles.push(new Particle(layer));
        }
      }
    }

    function startAnimation() {
      if (!ctx) return;
      if (animationId !== null) {
        cancelAnimationFrame(animationId);
      }
      lastTime = 0;
      animationId = requestAnimationFrame(animate);
    }

    function animate(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const dt = (timestamp - lastTime) / 1000;
      lastTime = timestamp;

      ctx.globalAlpha = 1;
      ctx.fillStyle = "black";
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      if (sourceImage) {
        drawImageFit(ctx, sourceImage, canvas.width, canvas.height);
      }

      for (const p of particles) {
        p.update(dt);
        p.draw(ctx);
      }
      ctx.globalAlpha = 1;

      if (recording && performance.now() >= recordEndTime) {
        stopRecording();
      }

      animationId = requestAnimationFrame(animate);
    }

    function getSupportedMime(codecChoice) {
      if (!window.MediaRecorder) return "";
      const candidatesByChoice = {
        h264: [
          "video/mp4;codecs=avc1",
          "video/webm;codecs=h264",
          "video/webm"
        ],
        vp9: ["video/webm;codecs=vp9", "video/webm"],
        vp8: ["video/webm;codecs=vp8", "video/webm"],
        auto: [
          "video/webm;codecs=vp9",
          "video/webm;codecs=vp8",
          "video/webm"
        ]
      };
      const candidates = candidatesByChoice[codecChoice] || candidatesByChoice.auto;
      for (const type of candidates) {
        if (MediaRecorder.isTypeSupported(type)) return type;
      }
      return "";
    }

    function startRecording() {
      if (!sourceImage) {
        setStatus("Load an image before recording.", true);
        return;
      }
      if (!window.MediaRecorder || !canvas.captureStream) {
        setStatus("MediaRecorder or canvas.captureStream not supported.", true);
        return;
      }

      const duration = parseFloat(durationInput.value) || 5;
      targetFPS = parseInt(fpsInput.value, 10) || 30;
      const requestedBitrateKbps = parseInt(bitrateInput.value, 10);
      const videoBitsPerSecond =
        Number.isFinite(requestedBitrateKbps) && requestedBitrateKbps > 0
          ? requestedBitrateKbps * 1000
          : undefined;

      applyResolution();
      buildStarMask();
      createParticles();
      startAnimation();

      const stream = canvas.captureStream(targetFPS);
      const codecChoice = codecSelect.value;
      const mimeType = getSupportedMime(codecChoice);
      const options = mimeType ? { mimeType } : {};
      if (videoBitsPerSecond) {
        options.videoBitsPerSecond = videoBitsPerSecond;
      }

      try {
        recorder = new MediaRecorder(stream, options);
      } catch (err) {
        console.error(err);
        setStatus("Failed to start MediaRecorder: " + err.message, true);
        return;
      }

      recordedChunks = [];
      recorder.ondataavailable = (e) => {
        if (e.data && e.data.size > 0) recordedChunks.push(e.data);
      };
      recorder.onstop = () => {
        const type = recorder.mimeType || "video/webm";
        const blob = new Blob(recordedChunks, { type });
        const url = URL.createObjectURL(blob);
        const extension = type.includes("mp4") ? "mp4" : "webm";

        const a = document.createElement("a");
        a.href = url;
        a.download = `star_particles.${extension}`;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => {
          document.body.removeChild(a);
          URL.revokeObjectURL(url);
        }, 100);

        setStatus(`Recording complete. Saved as ${extension.toUpperCase()} (${type}).`);
      };

      recordEndTime = performance.now() + duration * 1000;
      recording = true;
      recorder.start();
      const bitrateLabel = videoBitsPerSecond
        ? `${(videoBitsPerSecond / 1000).toLocaleString()} kbps`
        : "browser default bitrate";

      setStatus(
        `Recording for ${duration.toFixed(1)}s at ~${targetFPS}fps using ${mimeType || "default codec"} at ${bitrateLabel}...`
      );
    }

    function stopRecording() {
      if (recorder && recorder.state !== "inactive") {
        recorder.stop();
      }
      recording = false;
    }

    // === Event wiring ===
    imageLoader.addEventListener("change", (e) => {
      const file = e.target.files && e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          sourceImage = img;
          crop.x = 0;
          crop.y = 0;
          crop.w = img.naturalWidth;
          crop.h = img.naturalHeight;
          crop.enabled = false;
          cropToggle.checked = false;
          syncCropInputsFromImage();
          setStatus("Image loaded. Click Preview to start animation.");
          applyResolution();
          buildStarMask();
          createParticles();
          startAnimation();
        };
        img.onerror = (err) => {
          console.error("Image load error:", err);
          setStatus("Failed to load image. Try another file.", true);
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    redThresholdInput.addEventListener("input", () => {
      if (!sourceImage) return;
      buildStarMask();
      createParticles();
    });

    // When resolution changes, rebuild everything
    resolutionSelect.addEventListener("change", () => {
      const value = resolutionSelect.value;
      if (value !== "custom") {
        setResolutionPreset(value);
      }
      refreshAfterResolutionChange();
      syncPresetSelection();
    });

    widthInput.addEventListener("change", () => {
      syncPresetSelection();
      refreshAfterResolutionChange();
    });

    heightInput.addEventListener("change", () => {
      syncPresetSelection();
      refreshAfterResolutionChange();
    });

      // NEW: react to particle tuning changes
      [
        particlesInput,
        sizeInput,
        speedInput,
        windInput,
        lifeMinInput,
        lifeMaxInput,
        coneOriginXInput,
        coneOriginYInput,
        coneDirectionInput,
        coneSpreadInput,
        coneCenterBiasInput
      ].forEach(el => {
        el.addEventListener("input", () => {
          if (!sourceImage) return;
          readParticleSettings();
          createParticles();
          setStatus("Particle parameters updated.");
        });
      });

    [spiralCenterXInput, spiralCenterYInput].forEach(el => {
      el.addEventListener("input", () => {
        if (!sourceImage) return;
        readSpiralCenter();
        createParticles();
        setStatus("Spiral / radial center updated.");
      });
    });

    flowModeSelect.addEventListener("change", () => {
      if (!sourceImage) return;
      readParticleSettings();
      createParticles();
      setStatus("Flow pattern updated.");
    });

    [cropToggle, cropXInput, cropYInput, cropWInput, cropHInput].forEach(el => {
      el.addEventListener("input", () => applyCropChange());
      el.addEventListener("change", () => applyCropChange());
    });

    cropToViewportBtn.addEventListener("click", () => {
      if (!sourceImage) return;
      setCropToViewportCenter();
    });

    previewBtn.addEventListener("click", () => {
      if (!sourceImage) {
        setStatus("Load an image before starting preview.", true);
        return;
      }
      applyResolution();
      buildStarMask();
      createParticles();
      startAnimation();
      setStatus("Preview running. Adjust sliders to tune the look.");
    });

    recordBtn.addEventListener("click", () => {
      if (recording) {
        stopRecording();
      } else {
        startRecording();
      }
    });

    // Initialize canvas size
    applyResolution();
    readSpiralCenter();
    syncPresetSelection();
    setDetectionStatus("Detection results will show here after loading an image.");
  </script>
</body>
</html>
